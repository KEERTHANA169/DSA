import java.util.*;

class Solution {
    public String longestDupSubstring(String s) {
        int n = s.length();
        int left = 1, right = n, start = -1;

        int base1 = 256, base2 = 257;
        long mod1 = 1000000007, mod2 = 1000000009;

        while (left <= right) {
            int mid = (left + right) / 2;
            int idx = search(s, mid, base1, base2, mod1, mod2);
            if (idx != -1) {
                start = idx;
                left = mid + 1; // try longer
            } else {
                right = mid - 1; // try shorter
            }
        }

        return start == -1 ? "" : s.substring(start, start + left - 1);
    }

    // Check duplicate substring of length L using double hash
    private int search(String s, int L, int base1, int base2, long mod1, long mod2) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < L; i++) {
            h1 = (h1 * base1 + s.charAt(i)) % mod1;
            h2 = (h2 * base2 + s.charAt(i)) % mod2;
        }
        Set<Long> seen = new HashSet<>();
        seen.add((h1 << 32) | h2); // combine two hashes into single long
        long pow1 = 1, pow2 = 1;
        for (int i = 1; i <= L; i++) {
            pow1 = (pow1 * base1) % mod1;
            pow2 = (pow2 * base2) % mod2;
        }
        for (int i = 1; i <= s.length() - L; i++) {
            h1 = (h1 * base1 - s.charAt(i - 1) * pow1 % mod1 + mod1) % mod1;
            h1 = (h1 + s.charAt(i + L - 1)) % mod1;

            h2 = (h2 * base2 - s.charAt(i - 1) * pow2 % mod2 + mod2) % mod2;
            h2 = (h2 + s.charAt(i + L - 1)) % mod2;

            long combined = (h1 << 32) | h2;
            if (seen.contains(combined)) return i;
            seen.add(combined);
        }
        return -1;
    }
}
